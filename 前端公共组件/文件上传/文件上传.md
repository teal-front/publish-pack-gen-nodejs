# 可分片、续传的上传组件 WebUploader

官网：[http://fex.baidu.com/webuploader/](http://fex.baidu.com/webuploader/ "")

## 1. 主要功能
> * 多文件上传
> * 文件分片上传，提高并发速度
> * 分片传输失败，只需要重传失败的片
> * 现代浏览器支持拖拽，粘贴操作

## 2.基本用法

### A. 前端部分


引入js、css文件，另外组件还依赖jquery
```html
<link rel="stylesheet" type="text/css" href="http://res.hzins.com/web/public/webuploader/webuploader.css">
<script type="text/javascript" src="http://res.hzins.com/long/public/framework/jquery/jquery-1.8.3.min.js"></script>
<script type="text/javascript" src="http://res.hzins.com/web/public/webuploader/webuploader.js"></script>
```

html内容
```html
<div id="uploader" class="uploader">
    <ul id="file-list">
    </ul>

    <div class="btns">
        <span id="picker">选择文件</span>
        <button id="doUplaod">开始上传</button>
    </div>
</div>
```

js内容，实例化上传对象，并做相应配置

```javascript
<script type="text/javascript">
// uploader配置
var uploader = WebUploader.create({
    swf: '/web/public/Uploader.swf',
    server: '/upload',// 后台路径
    pick: '#picker', // 选择文件的按钮。可选。内部根据当前运行是创建，可能是input元素，也可能是flash.
    resize: false,// 不压缩image, 默认如果是jpeg，文件上传前会压缩一把再上传！
    chunked: true, // 是否分片
    chunkSize: 52428*100, // 分片大小， 5M
    dnd: '#uploader' // 拖拽目标
});

// 点击上传
$('body').on('click', '#doUplaod', function () {
    uploader.upload();
})
</script>
```


![uploader1.png](files/uploader1.png "")


完成这些设置后，选择文件并上传，将会向后台提交 "multipart/form-data" 类型的表单数据


### B. 后台部分
上传组件向后台POST "multipart/form-data" 类型的数据，抓包如下

![http.png](files/http.png "")

部分参数说明

> * chunk： 当前分片编号（配合chunks实现文件合并，不分片文件无此参数）
> * chunks： 总分片数量
> * md5： 文件校验值（不是分片）


**服务器程序应实现的功能**

> * 无chunk参数的文件，为不分片的完整文件，正常存储
> * 带chunk参数的文件，为分片文件，需要临时存储分片，并最后合并
> * 查询已上传分片的接口（用于续传，参见下面续传部分）


注意：由于旧浏览器使用flash上传，不支持cookie，登录态需通过post传递




[前端示例](demo/upload.html "") ，
[NODEJS后台示例](demo/app.js "") ，
[PHP后台示例（无查询分片接口）](demo/fileupload.php "") 


## 3. 续传、秒传的原理

文件上传前，向服务器查询已上传成功的分片（根据文件MD5+chunk实现唯一标识），忽略已上传分片，实现续传功能

也可通过文件md5值，判断文件是否已经上传，实现秒传功能


### WebUploader前端跳过分片示例（可参见[前端示例](demo/upload.html "")）

WebUploader提供hook，在分片上传前执行分片判断程序，即可忽略分片上传（通过返回reject状态的promise对象实现）

主要代码

```javascript
<script type="text/javascript">
var blockUplated = {};

// hook，需放在实例化Uploader的代码前
WebUploader.Uploader.register({
    // 分片上传前的处理
    'before-send': function(block) {
        var deferred = WebUploader.Base.Deferred();

        if ( isUploaded(block) ) {
            deferred.reject();
        }
        else {
            deferred.resolve();
        }

        return deferred.promise();
    },
    // 文件上传前的处理
    'before-send-file': function( file ) {
        var me = this,
            owner = this.owner,
            server = me.options.server,
            deferred = WebUploader.Deferred();
        
        // 校验文件
        owner.md5File( file.source )
        .fail(function() {
            deferred.reject();
        })
        .then(md5Done);
        
        // 校验完成
        function md5Done( md5 ) {
            file.md5 = md5;

            if ( !gChecked ) {
                $.ajax('/checkfile', {
                    dataType: 'json',
                    cache: false,
                    data: {
                        // md5: md5
                    },
                    success: function( re ) {
                        /*if ( re.exist ) {
                            owner.skipFile( file ); // 跳过文件
                        }*/
                        blockUplated = re;
                        deferred.resolve(); // 延迟对象resolve，则继续上传流程
                    }
                });
            }
            else {
                deferred.resolve();
            }
        }

        return deferred.promise();
    }
});

// 检查分片是否在分片列表中
function isUploaded( block ) {
    return $.inArray( block.file.md5 + '-' + block.chunk + '.part', blockUplated ) > -1;
}
</script>
