# 可分片、可续传的文件上传组件 WebUploader

官网：[http://fex.baidu.com/webuploader/](http://fex.baidu.com/webuploader/ "")

## 1. 主要功能
> * 多文件上传
> * 文件分片上传，提高并发速度
> * 分片传输失败，只需要重传失败的片
> * 现代浏览器支持拖拽，粘贴操作

## 2.基本用法

### A. 前端部分


引入js、css文件，另外组件还依赖jquery
```html
<link rel="stylesheet" type="text/css" href="http://res.hzins.com/web/public/webuploader/webuploader.css">
<script type="text/javascript" src="http://res.hzins.com/long/public/framework/jquery/jquery-1.8.3.min.js"></script>
<script type="text/javascript" src="http://res.hzins.com/web/public/webuploader/webuploader.js"></script>
```

html内容
```html
<div id="uploader" class="uploader">
    <ul id="file-list">
    </ul>

    <div class="btns">
        <span id="picker">选择文件</span>
        <button id="doUplaod">开始上传</button>
    </div>
</div>
```

实例化上传对象，并做相应设置，注意flash 和server路径不能域名

```javascript
<script type="text/javascript">
// uploader配置
var uploader = WebUploader.create({
    swf: '/web/public/Uploader.swf', // 跨域无效？
    server: '/upload',
    pick: '#picker', // 选择文件的按钮。可选。内部根据当前运行是创建，可能是input元素，也可能是flash.
    resize: false,// 不压缩image, 默认如果是jpeg，文件上传前会压缩一把再上传！
    chunked: true, // 是否分片
    chunkSize: 52428*100, // 分片大小， 5M

    dnd: '#uploader' // 拖拽
});

// 点击上传
$('body').on('click', '#doUplaod', function () {
    gChecked = false;
    uploader.upload();
})
</script>
```


![uploader1.png](files/uploader1.png "")


完成这些设置后，点击相应选择文件并上传，将会向后台提交 "multipart/form-data" 类型的表单数据


### B. 后台部分
上传组件向后台POST "multipart/form-data" 类型的表单数据，抓包如下

![http.png](files/http.png "")

数据除了包含一般文件信息和文件数据外，还附带其他参数，用于分片等操作

> * chunk： 当前分片编号
> * chunks： 总分片数量
> * md5： 文件校验值


**服务器程序应实现的功能**

> * 无chunk参数的文件，为不分片的完整文件，正常存储
> * 带chunk参数的文件，为分片文件，需要临时存储分片，并最后合并
> * 查询已上传分片的接口（用于续传，参见下面续传部分）


注意：由于旧浏览器使用flash实现上传，不支持cookie，登录态需通过post参数传递




[前端示例](demo/upload.html "") ，
[NODEJS后台示例](demo/app.js "") ，
[PHP后台示例（无查询分片接口）](demo/fileupload.php "") 


## 3. 续传、秒传的原理

文件上传前，向服务器请求已上传成功的分片（根据文件MD5+chunk实现唯一标识），忽略已上传分片，实现续传功能

也可通过文件md5值，判断文件是否已经上传，实现秒传功能


### WebUploader前端跳过分片示例（参见[前端示例](demo/upload.html "")）

WebUploader提供hook，在分片上传前执行分片判断程序，通过返回reject状态的promise对象，即可忽略分片上传

主要代码

```javascript
<script type="text/javascript">
var blockUplated = {};

// hook
WebUploader.Uploader.register({
    // 分片上传前的处理
    'before-send': function(block) {
        var deferred = WebUploader.Base.Deferred();

        if ( isUploaded(block) ) {
            deferred.reject();
        }
        else {
            deferred.resolve();
        }

        return deferred.promise();
    },
    // 文件上传前的处理
    'before-send-file': function( file ) {
        var me = this,
            owner = this.owner,
            server = me.options.server,
            deferred = WebUploader.Deferred();

        if (file.md5) {// 文件已经校验过
            md5Done(file.md5);
        }
        else {
            owner.md5File( file.source )
            .fail(function() {
                deferred.reject();
            })
            .then(md5Done);
        }

        $('#'+file.id).find(' .state').html('(校验中..)');

        function md5Done( md5 ) {
            file.md5 = md5;

            if ( !gChecked ) {
                gChecked = true;// 一次上传多个文件时， 只检查一次，直到再次点击上传
                $.ajax('/checkfile', {
                    dataType: 'json',
                    cache: false,
                    data: {
                        // md5: md5
                    },
                    success: function( re ) {
                        /*if ( re.exist ) {
                            owner.skipFile( file ); // 跳过文件
                        }*/
                        blockUplated = re;
                        deferred.resolve(); // 延迟对象resolve，则继续上传流程
                    }
                });
            }
            else {
                deferred.resolve();
            }
        }

        return deferred.promise();
    }
});

// 检查分片是否在服务器分片列表中
function isUploaded( block ) {
    return $.inArray( block.file.md5 + '-' + block.chunk + '.part', blockUplated ) > -1;
}
</script>
